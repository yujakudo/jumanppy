diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/jumanpp-1.02/src/common.h jumanpp-1.02/src/common.h
--- B:/msys64/tmp/jumanpp-1.02/src/common.h	Mon Oct  3 13:51:08 2016
+++ jumanpp-1.02/src/common.h	Wed Oct 11 12:55:00 2017
@@ -27,6 +27,11 @@
 #include <string.h>
 #include <float.h>
 #include "u8string.h"
+#include <boost/exception/exception.hpp>
+
+#if defined(_WIN32) && !defined(__CYGWIN__)
+#include <windows.h>
+#endif
 
 typedef std::unordered_map<std::string, double> Umap;
 
@@ -69,6 +74,8 @@ check_exceptional_chars_in_figure(const 
 
 extern size_t is_suuji(unsigned char *ucp);
 
+extern void BoostExceptionProc(void);
+
 #ifndef INT_MAX
 #define INT_MAX 2147483647
 #endif
@@ -154,6 +161,18 @@ extern size_t is_suuji(unsigned char *uc
 #define EXCEPTIONAL_FIGURE_EXPRESSION_LENGTH 6
 #define EXCEPTIONAL_FIGURE_EXPRESSION_LENGTH_2 9
 
+#define MEGABYTE (1024 * 1024)
+
+//  Get name of directory from file path
+#define GET_DIR_NAME(ppath) { \
+    int pos; char *p_c; \
+    pos = strlen(ppath)-1; \
+    p_c = (char *)(ppath) + pos; \
+    for(; pos>0; pos--, p_c--) if(*p_c=='\\' || *p_c=='/') break; \
+    *p_c = 0; \
+}
+#define IS_ABS_PATH(s_path) ( *(s_path)=='/' || *(s_path)=='\\' || *(s_path+1)==':')
+
 // split function with split_num
 template <class T>
 inline int split_string(const std::string &src, const std::string &key,
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/jumanpp-1.02/src/feature_vector.h jumanpp-1.02/src/feature_vector.h
--- B:/msys64/tmp/jumanpp-1.02/src/feature_vector.h	Mon Oct  3 13:43:17 2016
+++ jumanpp-1.02/src/feature_vector.h	Wed Sep 13 19:46:22 2017
@@ -20,6 +20,14 @@
 #include <boost/interprocess/containers/string.hpp>
 namespace bip = boost::interprocess;
 
+#define MEGABYTE (1024 * 1024)
+//  Initial map size in MByte when create.
+#ifdef _WIN32
+#define INITIAL_WEIGHT_SIZE_MB (200 * MEGABYTE)
+#else
+#define INITIAL_WEIGHT_SIZE_MB (1024 * MEGABYTE)
+#endif
+
 typedef std::unordered_map<std::string, double> Umap;
 typedef uint64_t Ulkey;
 typedef double Ulval;
@@ -56,6 +64,9 @@ class FeatureVector {/*{{{*/
     // メモリマップ操作用
     // Memory mapped file
     bool mmap_flag = false;
+#ifdef _WIN32
+    std::string name_to_shrink = ""; //  File name to shrink when destructed.
+#endif
 
     /* 共用イテレータ */
   public:
@@ -80,6 +91,11 @@ class FeatureVector {/*{{{*/
         if (p_file_weight != nullptr) {
             p_file_weight->flush();
             delete (p_file_weight);
+#ifdef _WIN32
+            if(name_to_shrink.length()>0) {
+                bip::managed_mapped_file::shrink_to_fit(name_to_shrink.c_str());
+            }
+#endif
         }
         dvec.release();
     } //}}}
@@ -199,7 +215,11 @@ class FeatureVector {/*{{{*/
         // メモリマップへの書き込みを flush
         p_file_weight->flush();
         // メモリマップのサイズ shrink
+#ifdef _WIN32
+        name_to_shrink = mapfile;
+#else
         bip::managed_mapped_file::shrink_to_fit(mapfile.c_str());
+#endif
         return true;
     };                                                                 //}}}
     bool dynamic_deserialize(std::ifstream &is, std::string mapfile) { //{{{
@@ -220,7 +240,8 @@ class FeatureVector {/*{{{*/
         mmap_flag = true;
 
         // 大きめに1GBとる (通常は40MB程度?，あとでshrink)
-        unsigned long long map_weight_size = 1024 * 1024 * 1024;
+        //  INITIAL_WEIGHT_SIZE_MB is defined at top of this file.
+        unsigned long long map_weight_size = INITIAL_WEIGHT_SIZE_MB;
         // メモリマップファイルを作成
         p_file_weight = new bip::managed_mapped_file(
             bip::create_only, mapfile.c_str(), map_weight_size);
@@ -250,8 +271,11 @@ class FeatureVector {/*{{{*/
         // メモリマップへの書き込みを flush
         p_file_weight->flush();
         // メモリマップのサイズ shrink
+#ifdef _WIN32
+        name_to_shrink = mapfile;
+#else
         bip::managed_mapped_file::shrink_to_fit(mapfile.c_str());
-
+#endif
         if (dvec->size() != size)
             return false;
         return true;
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/jumanpp-1.02/src/hash.h jumanpp-1.02/src/hash.h
--- B:/msys64/tmp/jumanpp-1.02/src/hash.h	Mon Oct  3 14:12:33 2016
+++ jumanpp-1.02/src/hash.h	Tue Sep 12 10:47:31 2017
@@ -3,6 +3,9 @@
 #include <vector>
 #include <string>
 #include <stdint.h>
+#if defined(_WIN32) && !defined(__CYGWIN__)
+#include <io.h>
+#endif
 
 typedef std::pair<uint64_t, uint64_t> OWORD;
 const OWORD constant = OWORD(0x87c37b91114253d5LLU, 0x4cf5ad432745937fLLU);
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/jumanpp-1.02/src/mmap.h jumanpp-1.02/src/mmap.h
--- B:/msys64/tmp/jumanpp-1.02/src/mmap.h	Wed Jul  6 15:13:31 2016
+++ jumanpp-1.02/src/mmap.h	Wed Oct 11 13:35:08 2017
@@ -12,7 +12,12 @@ extern "C" {
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <string.h>
+
+#if !defined(_WIN32) || defined(__CYGWIN__)
+// No need for MinGW
 #include <sys/mman.h>
+#endif
+
 #include <unistd.h>
 }
 
@@ -41,6 +46,20 @@ template <class T> class Mmap {
 #if defined(_WIN32) && !defined(__CYGWIN__)
     HANDLE hFile;
     HANDLE hMap;
+	jmp_buf jmp_env;
+	class jump_log {
+	public:
+		jmp_buf * penv = NULL;
+		jump_log(jmp_buf * penv) { this->penv = penv; }
+		~jump_log() { longjmp(*(this->penv), 1); }
+		int operator && (std::ostream &) { return 0; }
+	};
+#define CHECK_CLOSE_FALSE(condition) if(!(condition)) \
+	if(setjmp(this->jmp_env)==0) { \
+		this->close(); \
+		return false;  \
+	} else jump_log(&(this->jmp_env)) && std::cerr
+
 #else
     int fd;
     int flag;
@@ -62,7 +81,7 @@ template <class T> class Mmap {
 // This code is imported from sufary, develoved by
 //  TATUO Yamashita <yto@nais.to> Thanks!
 #if defined(_WIN32) && !defined(__CYGWIN__)
-    bool open(const char *filename, const char *mode = "r") {
+	bool open(const char *filename, const char *mode = "r") {
         this->close();
         unsigned long mode1, mode2, mode3;
         fileName = std::string(filename);
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/jumanpp-1.02/src/morph.cc jumanpp-1.02/src/morph.cc
--- B:/msys64/tmp/jumanpp-1.02/src/morph.cc	Tue Oct  4 10:23:38 2016
+++ jumanpp-1.02/src/morph.cc	Wed Oct 11 14:10:00 2017
@@ -23,6 +23,21 @@
 bool MODE_TRAIN = false;
 bool WEIGHT_AVERAGED = false;
 
+#if defined(DEFAULT_RESOURCE_PATH) && defined(_WIN32)
+//  Not use for Windows
+#undef DEFAULT_RESOURCE_PATH
+#endif
+
+#ifdef _WIN32
+std::string get_home_path() { /*{{{*/
+    std::string home_path;
+    char phome[MAX_PATH];
+    GetModuleFileName( NULL, phome, sizeof(phome));
+    GET_DIR_NAME(phome);
+    if( phome[0] ) home_path = phome;
+    return home_path;
+} /*}}}*/
+#else
 std::string get_home_path() { /*{{{*/
     char *phome;
     std::string home_path;
@@ -31,7 +46,18 @@ std::string get_home_path() { /*{{{*/
         home_path = phome;
     return home_path;
 } /*}}}*/
+#endif
 
+#ifdef _WIN32
+std::string get_current_path() { /*{{{*/
+    std::string home_path;
+    TCHAR phome[MAX_PATH];
+    if( GetCurrentDirectory(sizeof(phome)/sizeof(TCHAR), phome) ) {
+        home_path = phome;
+    }
+    return home_path;
+} /*}}}*/
+#else
 std::string get_current_path() { /*{{{*/
     char *phome;
     std::string home_path;
@@ -40,10 +66,16 @@ std::string get_current_path() { /*{{{*/
         home_path = phome;
     return home_path;
 } /*}}}*/
+#endif
 
 std::string read_jumanpprc() { /*{{{*/
     std::string home_path = get_home_path();
     std::string current_path = get_current_path();
+#ifdef _WIN32
+    std::string jumanpprc_path = home_path + "/jumanpprc";
+    std::string default_model_path = home_path + "/dics";
+
+#else   //  Not _WIN32
     std::string jumanpprc_path = home_path + "/.jumanpprc";
 
 #ifdef DEFAULT_RESOURCE_PATH
@@ -52,27 +84,40 @@ std::string read_jumanpprc() { /*{{{*/
     std::string default_model_path = current_path + "/.jumanpp";
 #endif
 
+#endif  //  Not _WIN32
+
     FILE *jumanpprc_file = fopen((jumanpprc_path).c_str(), "r");
     if (jumanpprc_file == NULL) {
         return default_model_path;
     } else {
-        char buffer[1024];
+        char buffer[1024], buffer2[1024];
         if (fscanf(jumanpprc_file, "%s", buffer) == 0) {
             fprintf(stderr,
                     "WARNING: .jumanpprc file does not contain valid path\n");
             return default_model_path;
         }
-        return buffer;
+        if( IS_ABS_PATH(buffer) ) return buffer;
+        //  std::stringで書き直す
+        strncpy(buffer2, (jumanpprc_path).c_str(), 1024);
+        buffer2[1023] = 0;
+        GET_DIR_NAME(buffer2);
+        strncat(buffer2, "/", 1024);
+        strncat(buffer2, buffer, 1024);
+        buffer2[1023] = 0;
+        return buffer2;
     }
 } /*}}}*/
 
 // オプション
 void option_proc(cmdline::parser &option, std::string model_path, int argc,
                  char **argv) { //{{{
+#ifdef _WIN32
+    std::string bin_dir = get_home_path();
+#else
     std::string bin_path(argv[0]);
     std::string bin_dir =
         bin_path.substr(0, bin_path.rfind('/')); // Windows 非対応
-
+#endif
     // 設定の読み込みオプション
     option.add<std::string>("dir", 'D', "set resource directory", false,
                             model_path);
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/jumanpp-1.02/src/pos.cc jumanpp-1.02/src/pos.cc
--- B:/msys64/tmp/jumanpp-1.02/src/pos.cc	Thu Sep  1 17:28:37 2016
+++ jumanpp-1.02/src/pos.cc	Tue Oct 10 16:14:29 2017
@@ -1,6 +1,13 @@
 #include "common.h"
 #include "pos.h"
 
+//  To diagnose boost exceptions.
+#include <boost/exception/get_error_info.hpp>
+#include <boost/exception/diagnostic_information.hpp>
+#include <boost/exception/errinfo_api_function.hpp>
+#include <boost/exception/errinfo_errno.hpp>
+#include <boost/exception/errinfo_file_name.hpp>
+
 namespace Morph {
 Pos::Pos() {}
 
@@ -54,11 +61,25 @@ bool Pos::write_pos_list(const std::stri
 } //}}}
 
 bool Pos::read_pos_list(const std::string &pos_filename) { //{{{
-    if (valid_mmap(pos_filename)) {
-        load_mmap(pos_filename);
-    } else {
-        load_selialized_map(pos_filename);
+    try {
+        if (valid_mmap(pos_filename)) {
+            load_mmap(pos_filename);
+        } else {
+            load_selialized_map(pos_filename);
+        }
+    } catch(...) {
+        BoostExceptionProc();
     }
     return true;
 } //}}}
+
+/**
+ * Show infomation of exception about Boost lib.
+ * then, exit.
+ */
+ void BoostExceptionProc(void) {
+    std::cerr << boost::current_exception_diagnostic_information(1) << "\n";
+    exit(-1);
+}
+
 }
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/jumanpp-1.02/src/pos.h jumanpp-1.02/src/pos.h
--- B:/msys64/tmp/jumanpp-1.02/src/pos.h	Mon Oct  3 13:47:03 2016
+++ jumanpp-1.02/src/pos.h	Wed Sep 13 18:41:18 2017
@@ -15,6 +15,13 @@
 #include <boost/unordered_map.hpp>
 namespace bip = boost::interprocess;
 
+//  Initial map size in MByte when create.
+#ifdef _WIN32
+#define INITIAL_POSMAP_SIZE_MB (2 * MEGABYTE)
+#else
+#define INITIAL_POSMAP_SIZE_MB (1024 * MEGABYTE)
+#endif
+
 typedef bip::managed_mapped_file::segment_manager mapped_file_manager;
 typedef bip::allocator<char, mapped_file_manager> allocator_char;
 typedef bip::allocator<void, mapped_file_manager> allocator_void;
@@ -82,7 +89,8 @@ class Pos {
         mmap_flag = true;
 
         // 大きめに1GBとる (通常は40MB程度?，あとでshrink)
-        unsigned long long map_size = 1024 * 1024 * 1024;
+        //  INITIAL_POSMAP_SIZE_MB is defined at top of this file.
+        unsigned long long map_size = INITIAL_POSMAP_SIZE_MB;
         // メモリマップファイルを作成
         p_file = new bip::managed_mapped_file(bip::create_only, mapfile.c_str(),
                                               map_size);
@@ -125,6 +133,9 @@ class Pos {
         // メモリマップへの書き込みを flush
         p_file->flush();
         // メモリマップのサイズ shrink
+#ifdef _WIN32
+        delete p_file;  //  Force to close file handle to avoid error.
+#endif
         bip::managed_mapped_file::shrink_to_fit(map_filename.c_str());
 
         return true;
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/jumanpp-1.02/src/rnnlm/rnnlmlib_dynamic.cpp jumanpp-1.02/src/rnnlm/rnnlmlib_dynamic.cpp
--- B:/msys64/tmp/jumanpp-1.02/src/rnnlm/rnnlmlib_dynamic.cpp	Wed Jun  1 16:25:40 2016
+++ jumanpp-1.02/src/rnnlm/rnnlmlib_dynamic.cpp	Wed Sep 13 19:06:46 2017
@@ -25,6 +25,18 @@
 #include <boost/unordered_map.hpp>
 #include "rnnlmlib_dynamic.h"
 
+#if defined(_WIN32) && !defined(__CYGWIN__)
+#include <io.h>
+#endif
+
+//  Initial map size in MByte when create.
+#define MEGABYTE (1024 * 1024)
+#ifdef _WIN32
+#define INITIAL_MAP_SIZE_MB (50 * MEGABYTE)
+#else
+#define INITIAL_MAP_SIZE_MB (1024 * MEGABYTE)
+#endif
+
 #ifndef exp10
     #define exp10(x) pow((double)10, (x))
 #endif
@@ -221,7 +233,7 @@ namespace RNNLM{
                 std::cerr << "read original file" << std::endl;
             
             // 大きめに1GB (10M文で85MB程度)とる(あとでshrink)
-            unsigned long long map_vocab_size = 1024 * 1024 * 1024; 
+            unsigned long long map_vocab_size = INITIAL_MAP_SIZE_MB; 
             // メモリマップファイルを作成
             p_file_vocab = new bip::managed_mapped_file(bip::create_only, MapVocabFilePath.c_str(), map_vocab_size ); 
             // メモリマップ内にvocablary 用の領域を確保
@@ -249,7 +261,14 @@ namespace RNNLM{
             // メモリマップへの書き込みを flush
             p_file_vocab->flush();
             // メモリマップのサイズ shrink
+#ifdef _WIN32
+            delete p_file_vocab;  //  Force to close file handle to avoid error.
             bip::managed_mapped_file::shrink_to_fit(MapVocabFilePath.c_str());
+            p_file_vocab = new bip::managed_mapped_file(bip::open_read_only, MapVocabFilePath.c_str());
+            vocab_map = p_file_vocab->find<umap_vocab>("map_vocab").first;
+#else
+            bip::managed_mapped_file::shrink_to_fit(MapVocabFilePath.c_str());
+#endif
         }
         fclose(vocab_file);
         
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/jumanpp-1.02/src/sentence.cc jumanpp-1.02/src/sentence.cc
--- B:/msys64/tmp/jumanpp-1.02/src/sentence.cc	Mon Dec 26 13:33:14 2016
+++ jumanpp-1.02/src/sentence.cc	Wed Sep 13 17:42:02 2017
@@ -77,7 +77,11 @@ void Sentence::init_rnnlm(RNNLM::CRnnLM 
 void Sentence::init_rnnlm_FR(RNNLM::CRnnLM *in_rnnlm) { /*{{{*/
     rnnlm = in_rnnlm;
     RNNLM::context tmp;
-    rnnlm->get_initial_context_FR(&tmp);
+    try {
+        rnnlm->get_initial_context_FR(&tmp);
+    } catch(...) {
+        BoostExceptionProc();
+    }
     initial_context = std::make_shared<RNNLM::context>(tmp);
 } /*}}}*/
 
